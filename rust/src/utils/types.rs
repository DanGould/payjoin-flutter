use std::collections::HashMap;

use flutter_rust_bridge::frb;
pub use payjoin_ffi::types::Network;

use crate::api::uri::FfiUrl;
use crate::frb_generated::RustOpaque;
// ///Represents data that needs to be transmitted to the receiver.
// ///You need to send this request over HTTP(S) to the receiver.
// #[derive(Clone, Debug)]
// pub struct Request {
//     ///URL to send the request to.
//     ///
//     ///This is full URL with scheme etc - you can pass it right to reqwest or a similar library.
//     pub url: Url,
//     ///Bytes to be sent to the receiver.
//     ///
//     ///This is properly encoded PSBT, already in base64. You only need to make sure Content-Type is text/plain and Content-Length is body.len() (most libraries do the latter automatically).
//     pub body: Vec<u8>,
// }

// impl From<Arc<payjoin_ffi::types::Request>> for Request {
//     fn from(value: Arc<payjoin_ffi::types::Request>) -> Self {
//         Self {
//             url: value.url.clone().into(),
//             body: value.body.clone(),
//         }
//     }
// }
// impl From<payjoin_ffi::types::Request> for Request {
//     fn from(value: payjoin_ffi::types::Request) -> Self {
//         Self {
//             url: value.url.clone().into(),
//             body: value.body.clone(),
//         }
//     }
// }

#[derive(Clone)]
pub struct Headers {
    pub map: HashMap<String, String>,
}
impl From<Headers> for payjoin_ffi::receive::v1::Headers {
    fn from(value: Headers) -> Self {
        payjoin_ffi::receive::v1::Headers(value.map)
    }
}

impl From<payjoin_ffi::receive::v1::Headers> for Headers {
    fn from(value: payjoin_ffi::receive::v1::Headers) -> Self {
        Headers { map: value.0 }
    }
}
impl Headers {
    pub fn from_vec(body: Vec<u8>) -> Headers {
        payjoin_ffi::receive::v1::Headers::from_vec(body).into()
    }
}

/// A reference to a transaction output.
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct OutPoint {
    /// The referenced transaction's txid.
    pub txid: String,
    /// The index of the referenced output in its transaction's vout.
    pub vout: u32,
}

impl From<OutPoint> for payjoin_ffi::types::OutPoint {
    fn from(value: OutPoint) -> Self {
        payjoin_ffi::types::OutPoint { txid: value.txid, vout: value.vout }
    }
}
impl From<&payjoin_ffi::types::OutPoint> for OutPoint {
    fn from(value: &payjoin_ffi::types::OutPoint) -> Self {
        OutPoint { txid: value.txid.clone(), vout: value.vout }
    }
}

#[derive(Debug, Clone)]
pub struct TxOut {
    /// The value of the output, in satoshis.
    pub value: u64,
    /// The address of the output.
    pub script_pubkey: Vec<u8>,
}

impl From<TxOut> for payjoin_ffi::types::TxOut {
    fn from(tx_out: TxOut) -> Self {
        payjoin_ffi::types::TxOut { value: tx_out.value, script_pubkey: tx_out.script_pubkey }
    }
}

impl From<payjoin_ffi::types::TxOut> for TxOut {
    fn from(tx_out: payjoin_ffi::types::TxOut) -> Self {
        TxOut { value: tx_out.value, script_pubkey: tx_out.script_pubkey }
    }
}

// It works with basic enums too
// Enums with struct variants are not yet supported
#[derive(Default)]
#[frb(mirror(Network))]
pub enum _Network {
    ///Bitcoin’s testnet
    #[default]
    Testnet,
    ///Bitcoin’s regtest
    Regtest,
    ///Classic Bitcoin
    Bitcoin,
    ///Bitcoin’s signet
    Signet,
}

pub struct ClientResponse(
    pub RustOpaque<std::sync::Mutex<core::option::Option<ohttp::ClientResponse>>>,
);

impl From<ClientResponse> for ohttp::ClientResponse {
    fn from(value: ClientResponse) -> Self {
        let mut data_guard = value.0.lock().unwrap();
        Option::take(&mut *data_guard).expect("ClientResponse moved out of memory")
    }
}
impl From<ohttp::ClientResponse> for ClientResponse {
    fn from(value: ohttp::ClientResponse) -> Self {
        Self(RustOpaque::new(std::sync::Mutex::new(Some(value))))
    }
}

#[derive(Clone)]
pub struct Request {
    pub url: FfiUrl,
    pub body: Vec<u8>,
}

impl From<payjoin_ffi::types::Request> for Request {
    fn from(value: payjoin_ffi::types::Request) -> Self {
        Self { url: (*value.url).clone().into(), body: value.body }
    }
}
